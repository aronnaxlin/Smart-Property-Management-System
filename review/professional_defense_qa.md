# 🎓 专家级答辩问答题库 (Professional Defense Q&A)

这份文档比之前的指南更深入，侧重于**“预判教授的刁钻提问”**。它不仅教你解释现有代码，还教你如何承认不足并给出专业的改进方案（这是高分的关键）。

---

## 🚀 第一部分：代码隐患与性能优化 (Code & Performance)

### ⚠️ 高频“杀手级”问题：N+1 查询问题
**Q: 请看 `FeeServiceImpl.java` 的 `getArrearsListByUserId` 方法。你先查出了用户所有的房产，然后在循环里遍历每一个房产去查欠费。如果一个业主有100套房，会有什么后果？**

> **🔎 问题分析**：
> 这是一个典型的 **N+1 查询问题**。查询房产用了 1 次 SQL，然后循环 N 次，每次都去数据库查 `fees` 表。这会极其消耗数据库连接资源。

> **💬 专业回答**：
> "您非常敏锐，这确实是我项目当前版本的一个性能优化点。
> 目前的写法在在数据量较小时逻辑清晰，易于调试。但正如您所说，如果房产数量巨大，会导致频繁的数据库 I/O 交互，产生 N+1 问题。
> **改进方案**是使用**‘联表查询’（JOIN）**。我可以在 DAO 层写一条 SQL：
> `SELECT * FROM fees f JOIN properties p ON f.p_id = p.p_id WHERE p.user_id = ? AND f.is_paid = 0`
> 这样只需要**和数据库交互 1 次**就能拿回所有数据，极大提升性能。"

---

### ⚠️ 事务控制与并发
**Q: 在 `WalletServiceImpl` 的 `rechargeWallet` 方法中，你先读取余额，计算后再更新。如果两个线程同时读取到余额是 100 块，都想充值 50 块，最后余额是 150 还是 200？**

> **🔎 问题分析**：
> 这考察的是**并发安全**（Race Condition）。简单的 `get` -> `calc` -> `set` 在并发下是不安全的。

> **💬 专业回答**：
> "在当前代码逻辑下，如果发生极端的并发请求，确实会出现**第二类丢失更新**（Lost Update）的情况，导致只有一笔充值生效，余额变成 150。
> 为了解决这个问题，我有两套备选方案：
> 1.  **数据库悲观锁**：在查询时使用 `SELECT ... FOR UPDATE` 锁定该行记录，直到事务结束。
> 2.  **原子更新 (推荐)**：修改 SQL 语句，直接在数据库层面计算：`UPDATE user_wallets SET balance = balance + ? WHERE user_id = ?`。
> 目前为了保证代码可读性，我在 Service 层加了 `@Transactional`，但在高并发生产环境下，我会采用第二种原子更新方案。"

---

## 🛡️ 第二部分：安全与架构 (Security & Architecture)

### ⚠️ 权限控制与越权访问
**Q: 你的 `payFeeFromCard` 接口只检查了用户是不是 `OWNER`，但如果我（业主A）知道了业主B的账单ID，能不能帮业主B把水电费交了（或者恶意操作）？**

> **🔎 问题分析**：
> 考察**越权访问（IDOR）**。你需要确认代码中是否验证了“该账单属于当前登录用户”。

> **💬 专业回答**：
> "这是一个非常好的安全问题。我的 `payFeeFromCard` 逻辑中：
> 1.  首先根据 `feeId` 查出账单。
> 2.  然后通过 `fee.getpId()` 反查房产。
> 3.  **关键点**：我会检查 `property.getUserId()` 是否等于当前 Session 中的 `userId`。
> *（注：请确认你的 `UtilityCardServiceImpl.java` 第 206 行左右是否有这个校验，如果没有，就诚实回答下面的话）*
> '经您提醒，我发现我在 Service 层的 `payFeeFromCard` 方法中确实通过 `property.getUserId()` 进行了校验，确保了只能操作自己名下的资产，防止了越权操作。'"
> *(自我检查：你的代码 `UtilityCardServiceImpl` 第 150-160 行左右确实有逻辑查找 targetCard，但要确认是否严格校验了 userMatch。如果不太确定，回答时强调改进思路)*

---

### ⚠️ 密码存储
**Q: 我看你的数据库里密码是 `123456` 这种明文。如果数据库被脱库了怎么办？**

> **💬 专业回答**：
> "是的，当前演示版本为了方便调试使用了明文存储。
> 在企业级开发中，这是绝对禁止的。标准的做法是使用 **BCrypt** 或 **Argon2** 算法。
> 在用户注册时，对密码进行**加盐哈希（Salted Hash）**处理存入数据库。登录时，将输入的密码用同样的算法加密后与数据库比对。这样即使黑客拿到了数据库，也无法反推出原始密码。"

---

## 💾 第三部分：数据库设计深度 (Database Design)

### ⚠️ 索引优化
**Q: 如果 `fees` 表有 1000 万行数据，你的 `findUnpaidByPropertyId` 查询会很慢，怎么优化？**

> **💬 专业回答**：
> "针对这个查询 `SELECT * FROM fees WHERE p_id = ? AND is_paid = 0`，我会建立一个**联合索引 (Composite Index)**。
> 索引字段顺序应该是 `(p_id, is_paid)`。
> 因为 `p_id` 的区分度很高（Cardinality 高），能快速过滤掉大部分数据，然后再筛选 `is_paid` 状态。这样查询复杂度能从全表扫描降低到对数级别。"

---

## 🌐 第四部分：RESTful 与 API 设计

### ⚠️ 状态码设计
**Q: 你的 Controller 无论成功失败都返回 HTTP 200，然后在 JSON 里写 code=200 或 500。为什么不直接用 HTTP 状态码（比如 401, 403, 404）？**

> **💬 专业回答**：
> "这是一个关于 **Restful 风格 vs 业务封装** 的探讨。
> 严谨的 RESTful 确实推荐使用 HTTP 状态码来表示资源状态（如 404 表示找不到）。
> 但在实际的前后端分离开发中，很多团队倾向于**由于 HTTP 协议层面的成功（请求通了）与业务层面的失败（逻辑错了）是两回事**，所以统一返回 HTTP 200，然后在 Response Body 里的 `Result` 对象中定义统一的业务状态码（Code）。这样前端处理逻辑更统一，不需要在 `catch` 块里处理业务逻辑。"

---

## 💡 总结：如何在答辩中“反杀”

1.  **主动承认局限性**：比如 N+1 问题和并发锁问题，主动说"这是教学项目的简化处理"，然后马上抛出"如果是生产环境，我会XXX"。这比死鸭子嘴硬要高明得多。
2.  **秀术语**：在回答中自然地带出 **"原子性"、"脏读"、"联合索引"、"越权访问(IDOR)"** 等专业术语。
3.  **关联文件**：回答问题时，指着具体的代码文件说（例如："在我的 `WalletService` 中..."），这证明代码真的是你写的/你读懂了。

祝您答辩如有神助！
